# Tema4
## Soluci贸n del problema 4
###### Adri谩n Montero Bonilla B88092
###### Alberto Arias Brenes B90639

A partir de la pr谩ctica E13 del curso de Modelos Probabil铆sticos de Se帽ales y Sistemas se trabaja para obtener una soluci贸n programada de este problema. 
Es importante recordar que un proceso estoc谩stico es en s铆 un proceso que est谩 compuesto por un conjunto de variables aleatorias en el tiempo, 煤til para describir sistemas din谩micos, el problema que se solucionar谩 se ejecuta a partir de una funci贸n dada y se determinar谩 el promedio y la autocorrelaci贸n de este. 

Se tiene el siguiente proceso: 
X(t) = Ccos(惟t + )

Adem谩s se define que: 

E[C] = 5 y  ^2  = 0.2, la variable aleatoria C es gaussiana

惟  es una variable aleatoria uniforme distribuida en [2  (59.1) , 2  (60.1)]

  es una variable aleatoria uniforme con intervalo [0 ,  /2 ]

Las tres variables aleatorias son estad铆sticamente independientes


### Parte A. Determinaci贸n del valor esperado de un proceso estoc谩stico.

Se debe considerar que la variable aleatoria  惟  es una constante y se obtiene el promedio de este proceso. Al indicar que esto es as铆, el proceso consta entonces de dos variables aleatorias, las funciones que le conforman variar谩n su amplitud y tambi茅n fase, pero la frecuencia de todas estas funciones ser谩 igual.

Inicialmente se deben importar librer铆as necesarias para la implementaci贸n del c贸digo 
```
import numpy as np
from scipy import stats
import matplotlib.pyplot as plt
import random
```

La librer铆a numpy se utiliza para el manejo de arreglos matem谩ticos, stats contiene una gran cantidad de distribuciones, matplotlib se utilizar谩 para generar gr谩ficos y darles formato, la librer铆a random para escoger un valor aleatorio en rangos determinados. 

Se definen las variables aleatorias, que son independientes entre s铆, para comprender correctamente el desarrollo es importante mencionar que la definici贸n de las variables C = C,  = vaTh y 惟 = vcO, teniendo esto en cuenta se muestra la implementaci贸n en Python.

```
vaC = stats.norm(5, np.sqrt(0.2)) # Gaussiana
vaTh = stats.uniform(0, np.pi/2) # Uniformemente distribuida
vcO = random.uniform(2*np.pi*59.1, 2*np.pi*60.1) # Omega

# Creaci贸n del vector de tiempo
T = 200	  # n煤mero de elementos
t_final = 10 # tiempo en segundos
t = np.linspace(0, t_final, T)

# Inicializaci贸n del proceso aleatorio X(t) con N realizaciones
N = 20
X_t = np.empty((N, len(t)))	# N funciones del tiempo x(t) con T puntos

# Creaci贸n de las muestras del proceso x(t), son las realizaciones
for i in range(N):
	C = vaC.rvs()
	Th = vaTh.rvs()
	x_t = C * np.cos(vcO*t + Th)
	X_t[i,:] = x_t
	plt.plot(t, x_t)

# Promedio de las N realizaciones en cada instante (cada punto en t)
Prom = [np.mean(X_t[:,i]) for i in range(len(t))]
plt.plot(t, Prom, lw=6, label='Promedio de las N realizaciones') 

# Se grafica el resultado te贸rico del valor esperado
E = 10/np.pi * (np.cos(vcO*t) - np.sin(vcO*t)) #Esto viene de la soluci贸n a mano, te贸rica
plt.plot(t, E, '-.', lw=4, label='Resultado te贸rico del promedio')


# Mostrar las realizaciones, y su promedio calculado y te贸rico
plt.title('Realizaciones del proceso aleatorio $X(t)$')
plt.xlabel('$t$')
plt.ylabel('$x_i(t)$')
plt.legend()
plt.show()
```
Al correr el c贸digo, se tiene la escogencia de un valor de 惟 = 373.4695, esto est谩 dentro del rango de valores posibles
Se obtiene la siguiente gr谩fica:

**

Al utilizar las funciones de Python para encontrar el promedio de este proceso estoc谩stico se puede observar que la funci贸n de promedio te贸rica, calza de una forma adecuada y aproximada al promedio de las realizaciones generadas.

Es bueno comprender que al notar esta concordancia, se puede comprobar que al ser estad铆sticamente independientes la funci贸n de densidad conjunta es la multiplicaci贸n de cada funci贸n de densidad individual de las variables aleatorias y que el promedio de este proceso ir谩 variando en el tiempo de forma sinusoidal, aumentando o disminuyendo su valor de forma peri贸dica.

Adem谩s, de la gr谩fica generada se pueden denotar aspectos de importancia; primero como se ha dicho antes se puede ver que las realizaciones del proceso poseen una misma frecuencia ya que este valor se ha definido constante, pero su amplitud y fase var铆an. Estas variaciones son peque帽as, esto responde a que para la amplitud (C) la desviaci贸n est谩ndar es peque帽a y es por esto que las funciones est谩n muy juntas entre s铆, dando con que el promedio tambi茅n se ajuste bastante, que se vean tan juntas las funciones, igualmente la fase tiene un peque帽o rango de cambio y siendo eso as铆, las variaciones de fase no se ven significativas.





### Parte B. Autocorrelaci贸n de un proceso estoc谩stico. 

La realizaci贸n de esta parte consisti贸 en calcular la autocorrelaci贸n para el nuevo proceso aleatorio al considerar tanto a 惟 como a  como constantes. Al hacer esto, hay que realizar el mismo procedimiento que se le hizo al proceso de la parte A pero esta vez para la nueva expresi贸n de X(t) dada. 

![image](https://user-images.githubusercontent.com/93066389/142434066-062af162-953b-4e15-ab74-2445a043d52f.png)

```
# Variables aleatoria C
vaC = stats.norm(5, np.sqrt(0.2))
omega = 3 #Ahora tanto Omega como Theta son constantes, se escogen valores arbitrarios.
theta = 1

# Creaci贸n del vector de tiempo
T = 100	  # n煤mero de elementos
t_final = 10	# tiempo en segundos
t = np.linspace(0, t_final, T)

# Inicializaci贸n del proceso aleatorio X(t) con N realizaciones
N = 10
X_t = np.empty((N, len(t)))	# N funciones del tiempo x(t) con T puntos

# Creaci贸n de las muestras del proceso x(t)
# N贸tese que ya que tenemos otro proceso aleatorio X(t) disitnto, hay que repetir
# los mismos pasos que se siguieron en la parte A pero para el nuevo proceso aleatorio.
for i in range(N):
	C = vaC.rvs()
	x_t = C * np.cos(omega*t + theta)
	X_t[i,:] = x_t
```

Una vez finalizado lo anterior, se procede a calcular la autocorrelaci贸n. Para esto, simplemente se deja el c贸digo tal y como se ten铆a en el archivo L4_base.py,pero se cambia la ecuaci贸n de Rxx por el dado en la soluci贸n del problema 4. 

![image](https://user-images.githubusercontent.com/93066389/142434814-4b7d19e1-b655-4357-8545-f8bd15968de0.png)

```
# T valores de desplazamiento tau
desplazamiento = np.arange(T)
taus = desplazamiento/t_final

# Inicializaci贸n de matriz de valores de correlaci贸n para las N funciones
corr = np.empty((N, len(desplazamiento)))

# Nueva figura para la autocorrelaci贸n
plt.figure()

# C谩lculo de correlaci贸n para cada valor de t
for n in range(N):
	for i, tau in enumerate(desplazamiento):
		corr[n, i] = np.correlate(X_t[n,:], np.roll(X_t[n,:], tau))/T
	plt.plot(taus, corr[n,:])

# Valor te贸rico de correlaci贸n
# Aqu铆 se cambia la ecuaci贸n de Rxx por la dada en el problema 4.
Rxx = 25.2*np.cos(omega*t+theta)*np.cos(omega*(t+taus)+theta)

# Gr谩ficas de correlaci贸n para cada realizaci贸n y la
plt.plot(taus, Rxx, '-.', lw=4, label='Correlaci贸n te贸rica')
plt.title('Funciones de autocorrelaci贸n de las realizaciones del proceso')
plt.xlabel(r'$\tau$')
plt.ylabel(r'$R_{WW}(\tau)$')
plt.legend()
plt.show()
```
Finalmente, se obtiene la gr谩fica resultante para la autocorrelaci贸n. 

![image](https://user-images.githubusercontent.com/93066389/142442476-35c3952e-d6f6-4cb0-bfd9-40351ed982d1.png)



