# Tema4
## Solución del problema 4
###### Adrián Montero Bonilla B88092
###### Alberto Arias Brenes B90639

A partir de la práctica E13 del curso de Modelos Probabilísticos de Señales y Sistemas se trabaja para obtener una solución programada de este problema. 
Es importante recordar que un proceso estocástico es en sí un proceso que está compuesto por un conjunto de variables aleatorias en el tiempo, útil para describir sistemas dinámicos, el problema que se solucionará se ejecuta a partir de una función dada y se determinará el promedio y la autocorrelación de este. 

### Parte A. Determinación del valor esperado de un proceso estocástico.










### Parte B. Autocorrelación de un proceso estocástico. 

La realización de esta parte consistió en calcular la autocorrelación para el nuevo proceso aleatorio al considerar tanto a Omega como a Theta como constantes. Al hacer esto, hay que realizar el mismo procedimiento que se le hizo al proceso de la parte A pero esta vez para la nueva expresión de X(t) dada. 

![image](https://user-images.githubusercontent.com/93066389/142434066-062af162-953b-4e15-ab74-2445a043d52f.png)

```
# Variables aleatoria C
vaC = stats.norm(5, np.sqrt(0.2))
omega = 3 #Ahora tanto Omega como Theta son constantes, se escogen valores arbitrarios.
theta = 1

# Creación del vector de tiempo
T = 100			# número de elementos
t_final = 10	# tiempo en segundos
t = np.linspace(0, t_final, T)

# Inicialización del proceso aleatorio X(t) con N realizaciones
N = 10
X_t = np.empty((N, len(t)))	# N funciones del tiempo x(t) con T puntos

# Creación de las muestras del proceso x(t)
# Nótese que ya que tenemos otro proceso aleatorio X(t) disitnto, hay que repetir
# los mismos pasos que se siguieron en la parte A pero para el nuevo proceso aleatorio.
for i in range(N):
	C = vaC.rvs()
	x_t = C * np.cos(omega*t + theta)
	X_t[i,:] = x_t
```

Una vez finalizado lo anterior, se procede a calcular la autocorrelación. Para esto, simplemente se deja el código tal y como se tenía en el archivo L4_base.py,pero se cambia la ecuación de Rxx por el dado en la solución del problema 4. 

![image](https://user-images.githubusercontent.com/93066389/142434814-4b7d19e1-b655-4357-8545-f8bd15968de0.png)

```
# T valores de desplazamiento tau
desplazamiento = np.arange(T)
taus = desplazamiento/t_final

# Inicialización de matriz de valores de correlación para las N funciones
corr = np.empty((N, len(desplazamiento)))

# Nueva figura para la autocorrelación
plt.figure()

# Cálculo de correlación para cada valor de t
for n in range(N):
	for i, tau in enumerate(desplazamiento):
		corr[n, i] = np.correlate(X_t[n,:], np.roll(X_t[n,:], tau))/T
	plt.plot(taus, corr[n,:])

# Valor teórico de correlación
# Aquí se cambia la ecuación de Rxx por la dada en el problema 4.
Rxx = 25.2*np.cos(omega*t+theta)*np.cos(omega*(t+taus)+theta)

# Gráficas de correlación para cada realización y la
plt.plot(taus, Rxx, '-.', lw=4, label='Correlación teórica')
plt.title('Funciones de autocorrelación de las realizaciones del proceso')
plt.xlabel(r'$\tau$')
plt.ylabel(r'$R_{WW}(\tau)$')
plt.legend()
plt.show()
```
Finalmente, se obtiene la gráfica resultante para la autocorrelación. 

![image](https://user-images.githubusercontent.com/93066389/142442476-35c3952e-d6f6-4cb0-bfd9-40351ed982d1.png)



